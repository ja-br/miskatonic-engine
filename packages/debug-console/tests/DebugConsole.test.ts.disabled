import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { DebugConsole } from '../src/DebugConsole';
import { CommandSystem } from '@miskatonic/core';
import { EventBus } from '@miskatonic/events';

describe('DebugConsole', () => {
  let debugConsole: DebugConsole;
  let commandSystem: CommandSystem;
  let eventBus: EventBus;

  beforeEach(() => {
    // Create command system
    eventBus = new EventBus();
    commandSystem = new CommandSystem(eventBus);

    // Register some test commands
    commandSystem.register({
      name: 'test',
      description: 'Test command',
      execute: async () => 'Test executed',
    });

    commandSystem.register({
      name: 'error',
      description: 'Error command',
      execute: async () => {
        throw new Error('Test error');
      },
    });

    // Create debug console
    debugConsole = new DebugConsole(commandSystem, {
      initiallyVisible: false,
      captureConsole: false, // Don't capture console in tests
      persistHistory: false,
    });
  });

  afterEach(() => {
    if (debugConsole) {
      debugConsole.shutdown();
    }
    eventBus.destroy();
  });

  describe('initialization', () => {
    it('should create console with default config', () => {
      expect(debugConsole).toBeDefined();
    });

    it('should initialize and create UI', () => {
      debugConsole.initialize();

      const consoleElement = document.getElementById('miskatonic-debug-console');
      expect(consoleElement).not.toBeNull();
    });

    it('should not be visible initially', () => {
      debugConsole.initialize();
      expect(debugConsole.isVisible()).toBe(false);
    });

    it('should be visible if configured', () => {
      const visibleConsole = new DebugConsole(commandSystem, { initiallyVisible: true });
      visibleConsole.initialize();

      expect(visibleConsole.isVisible()).toBe(true);

      visibleConsole.shutdown();
    });

    it('should log initialization message', () => {
      debugConsole.initialize();

      const logs = debugConsole.getLogs();
      expect(logs.length).toBeGreaterThan(0);
      expect(logs[0].message).toContain('Debug console initialized');
    });
  });

  describe('shutdown', () => {
    it('should remove UI elements', () => {
      debugConsole.initialize();
      debugConsole.shutdown();

      const consoleElement = document.getElementById('miskatonic-debug-console');
      expect(consoleElement).toBeNull();
    });

    it('should restore console methods if captured', () => {
      const originalLog = console.log;
      const consoleWithCapture = new DebugConsole(commandSystem, { captureConsole: true });

      consoleWithCapture.initialize();
      expect(console.log).not.toBe(originalLog);

      consoleWithCapture.shutdown();
      expect(console.log).toBe(originalLog);
    });
  });

  describe('show/hide/toggle', () => {
    beforeEach(() => {
      debugConsole.initialize();
    });

    it('should show console', () => {
      debugConsole.show();
      expect(debugConsole.isVisible()).toBe(true);

      const element = document.getElementById('miskatonic-debug-console');
      expect(element?.style.display).toBe('flex');
    });

    it('should hide console', () => {
      debugConsole.show();
      debugConsole.hide();

      expect(debugConsole.isVisible()).toBe(false);

      const element = document.getElementById('miskatonic-debug-console');
      expect(element?.style.display).toBe('none');
    });

    it('should toggle visibility', () => {
      expect(debugConsole.isVisible()).toBe(false);

      debugConsole.toggle();
      expect(debugConsole.isVisible()).toBe(true);

      debugConsole.toggle();
      expect(debugConsole.isVisible()).toBe(false);
    });

    it('should not show if already visible', () => {
      debugConsole.show();
      const firstCall = debugConsole.isVisible();

      debugConsole.show();
      const secondCall = debugConsole.isVisible();

      expect(firstCall).toBe(true);
      expect(secondCall).toBe(true);
    });
  });

  describe('logging', () => {
    beforeEach(() => {
      debugConsole.initialize();
    });

    it('should log messages', () => {
      debugConsole.log('Test message', 'info');

      const logs = debugConsole.getLogs();
      const testLog = logs.find(l => l.message === 'Test message');

      expect(testLog).toBeDefined();
      expect(testLog?.level).toBe('info');
    });

    it('should default to info level', () => {
      debugConsole.log('Default level');

      const logs = debugConsole.getLogs();
      const testLog = logs.find(l => l.message === 'Default level');

      expect(testLog?.level).toBe('info');
    });

    it('should support all log levels', () => {
      debugConsole.log('Debug', 'debug');
      debugConsole.log('Info', 'info');
      debugConsole.log('Warn', 'warn');
      debugConsole.log('Error', 'error');

      const logs = debugConsole.getLogs();
      expect(logs.some(l => l.level === 'debug')).toBe(true);
      expect(logs.some(l => l.level === 'info')).toBe(true);
      expect(logs.some(l => l.level === 'warn')).toBe(true);
      expect(logs.some(l => l.level === 'error')).toBe(true);
    });

    it('should include timestamps', () => {
      const before = Date.now();
      debugConsole.log('Test');
      const after = Date.now();

      const logs = debugConsole.getLogs();
      const testLog = logs.find(l => l.message === 'Test');

      expect(testLog?.timestamp).toBeGreaterThanOrEqual(before);
      expect(testLog?.timestamp).toBeLessThanOrEqual(after);
    });

    it('should maintain max log entries', () => {
      const maxEntries = 1000; // Default max

      for (let i = 0; i < maxEntries + 100; i++) {
        debugConsole.log(`Message ${i}`);
      }

      const logs = debugConsole.getLogs();
      expect(logs.length).toBeLessThanOrEqual(maxEntries);
    });

    it('should assign unique IDs to logs', () => {
      debugConsole.log('Message 1');
      debugConsole.log('Message 2');
      debugConsole.log('Message 3');

      const logs = debugConsole.getLogs();
      const ids = logs.map(l => l.id);

      expect(new Set(ids).size).toBe(ids.length); // All unique
    });
  });

  describe('clear', () => {
    beforeEach(() => {
      debugConsole.initialize();
    });

    it('should clear all logs', () => {
      debugConsole.log('Message 1');
      debugConsole.log('Message 2');

      debugConsole.clear();

      expect(debugConsole.getLogs()).toEqual([]);
    });

    it('should clear UI output', () => {
      debugConsole.log('Message');
      debugConsole.clear();

      const output = document.querySelector('#miskatonic-debug-console div');
      expect(output?.children.length).toBe(0);
    });
  });

  describe('executeCommand', () => {
    beforeEach(() => {
      debugConsole.initialize();
    });

    it('should execute registered command', async () => {
      await debugConsole.executeCommand('test');

      const logs = debugConsole.getLogs();
      expect(logs.some(l => l.message.includes('> test'))).toBe(true);
    });

    it('should add command to history', async () => {
      await debugConsole.executeCommand('test');

      const history = debugConsole.getHistory();
      expect(history).toContain('test');
    });

    it('should log errors from commands', async () => {
      await debugConsole.executeCommand('error');

      const logs = debugConsole.getLogs();
      const errorLog = logs.find(l => l.level === 'error');

      expect(errorLog).toBeDefined();
      expect(errorLog?.message).toContain('Test error');
    });

    it('should ignore empty commands', async () => {
      const logsBefore = debugConsole.getLogs().length;

      await debugConsole.executeCommand('');
      await debugConsole.executeCommand('   ');

      const logsAfter = debugConsole.getLogs().length;
      expect(logsAfter).toBe(logsBefore);
    });

    it('should trim command whitespace', async () => {
      await debugConsole.executeCommand('  test  ');

      const history = debugConsole.getHistory();
      expect(history).toContain('  test  ');
    });
  });

  describe('history management', () => {
    beforeEach(() => {
      debugConsole.initialize();
    });

    it('should return command history', async () => {
      await debugConsole.executeCommand('test');
      await debugConsole.executeCommand('error');

      const history = debugConsole.getHistory();
      expect(history).toEqual(['test', 'error']);
    });

    it('should clear history', async () => {
      await debugConsole.executeCommand('test');

      debugConsole.clearHistory();

      expect(debugConsole.getHistory()).toEqual([]);
    });
  });

  describe('autocomplete', () => {
    beforeEach(() => {
      debugConsole.initialize();
    });

    it('should get suggestions for commands', () => {
      const suggestions = debugConsole.getSuggestions('te');
      expect(suggestions).toContain('test');
    });

    it('should refresh autocomplete when requested', () => {
      // Register new command after initialization
      commandSystem.register({
        name: 'newcommand',
        description: 'New command',
        execute: async () => 'ok',
      });

      debugConsole.refreshAutocomplete();

      const suggestions = debugConsole.getSuggestions('new');
      expect(suggestions).toContain('newcommand');
    });
  });

  describe('console capture', () => {
    it('should capture console.log when enabled', () => {
      const captureConsole = new DebugConsole(commandSystem, {
        captureConsole: true,
        initiallyVisible: false,
      });

      captureConsole.initialize();

      console.log('Captured message');

      const logs = captureConsole.getLogs();
      expect(logs.some(l => l.message.includes('Captured message'))).toBe(true);

      captureConsole.shutdown();
    });

    it('should capture console.warn', () => {
      const captureConsole = new DebugConsole(commandSystem, { captureConsole: true });
      captureConsole.initialize();

      console.warn('Warning message');

      const logs = captureConsole.getLogs();
      const warnLog = logs.find(l => l.message.includes('Warning message'));
      expect(warnLog?.level).toBe('warn');

      captureConsole.shutdown();
    });

    it('should capture console.error', () => {
      const captureConsole = new DebugConsole(commandSystem, { captureConsole: true });
      captureConsole.initialize();

      console.error('Error message');

      const logs = captureConsole.getLogs();
      const errorLog = logs.find(l => l.message.includes('Error message'));
      expect(errorLog?.level).toBe('error');

      captureConsole.shutdown();
    });

    it('should still call original console methods', () => {
      const originalLog = console.log;
      const logSpy = vi.fn();
      console.log = logSpy;

      const captureConsole = new DebugConsole(commandSystem, { captureConsole: true });
      captureConsole.initialize();

      console.log('Test');

      expect(logSpy).toHaveBeenCalledWith('Test');

      captureConsole.shutdown();
      console.log = originalLog;
    });
  });

  describe('keyboard handling', () => {
    beforeEach(() => {
      debugConsole.initialize();
    });

    it('should toggle on ~ key press', () => {
      expect(debugConsole.isVisible()).toBe(false);

      const event = new KeyboardEvent('keydown', { code: 'Backquote' });
      document.dispatchEvent(event);

      expect(debugConsole.isVisible()).toBe(true);
    });

    it('should not toggle with modifier keys', () => {
      const event = new KeyboardEvent('keydown', {
        code: 'Backquote',
        ctrlKey: true,
      });

      document.dispatchEvent(event);

      expect(debugConsole.isVisible()).toBe(false);
    });
  });

  describe('configuration', () => {
    it('should use custom toggle key', () => {
      const customConsole = new DebugConsole(commandSystem, {
        toggleKey: 'F1',
      });

      customConsole.initialize();

      const event = new KeyboardEvent('keydown', { code: 'F1' });
      document.dispatchEvent(event);

      expect(customConsole.isVisible()).toBe(true);

      customConsole.shutdown();
    });

    it('should respect maxLogEntries', () => {
      const limitedConsole = new DebugConsole(commandSystem, {
        maxLogEntries: 5,
      });

      limitedConsole.initialize();

      for (let i = 0; i < 10; i++) {
        limitedConsole.log(`Message ${i}`);
      }

      expect(limitedConsole.getLogs().length).toBe(5);

      limitedConsole.shutdown();
    });
  });
});
